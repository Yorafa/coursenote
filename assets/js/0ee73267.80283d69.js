"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6181],{1091:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>a});var n=r(5893),o=r(1151);const i={},s="AVL Tree",l={id:"csc/csc263/AVL Tree",title:"AVL Tree",description:"A tree is an AVL Tree if it is binary search tree and AVL balanced.",source:"@site/docs/csc/csc263/AVL Tree.md",sourceDirName:"csc/csc263",slug:"/csc/csc263/AVL Tree",permalink:"/docs/csc/csc263/AVL Tree",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CSC263 Data Structures and Analysis",permalink:"/docs/csc/csc263/"},next:{title:"Amortized Analysis",permalink:"/docs/csc/csc263/Amortized Analysis"}},h={},a=[{value:"Implement",id:"implement",level:2},{value:"Worst-Case Time Complexity",id:"worst-case-time-complexity",level:2}];function c(e){const t={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"avl-tree",children:"AVL Tree"}),"\n",(0,n.jsxs)(t.p,{children:["A tree is an ",(0,n.jsx)(t.strong,{children:"AVL Tree"})," if it is ",(0,n.jsx)(t.a,{href:"./Binary%20Search%20Tree",children:"binary search tree"})," and AVL balanced."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"We first define the balance factor = #nodes of right subtree -  #nodes of left subtree"}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"AVL balanced"})," means that each node of this tree satisfied balance factor in range ",(0,n.jsxs)(t.span,{className:"katex",children:[(0,n.jsx)(t.span,{className:"katex-mathml",children:(0,n.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(t.semantics,{children:[(0,n.jsxs)(t.mrow,{children:[(0,n.jsx)(t.mo,{stretchy:"false",children:"["}),(0,n.jsx)(t.mo,{children:"\u2212"}),(0,n.jsx)(t.mn,{children:"1"}),(0,n.jsx)(t.mo,{separator:"true",children:","}),(0,n.jsx)(t.mn,{children:"1"}),(0,n.jsx)(t.mo,{stretchy:"false",children:"]"})]}),(0,n.jsx)(t.annotation,{encoding:"application/x-tex",children:"[-1, 1]"})]})})}),(0,n.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(t.span,{className:"base",children:[(0,n.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(t.span,{className:"mopen",children:"["}),(0,n.jsx)(t.span,{className:"mord",children:"\u2212"}),(0,n.jsx)(t.span,{className:"mord",children:"1"}),(0,n.jsx)(t.span,{className:"mpunct",children:","}),(0,n.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(t.span,{className:"mord",children:"1"}),(0,n.jsx)(t.span,{className:"mclose",children:"]"})]})})]})]}),"\n",(0,n.jsxs)(t.li,{children:["we also call balance factor in range ",(0,n.jsxs)(t.span,{className:"katex",children:[(0,n.jsx)(t.span,{className:"katex-mathml",children:(0,n.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(t.semantics,{children:[(0,n.jsxs)(t.mrow,{children:[(0,n.jsx)(t.mo,{stretchy:"false",children:"["}),(0,n.jsx)(t.mo,{children:"\u2212"}),(0,n.jsx)(t.mn,{children:"1"}),(0,n.jsx)(t.mo,{separator:"true",children:","}),(0,n.jsx)(t.mn,{children:"1"}),(0,n.jsx)(t.mo,{stretchy:"false",children:"]"})]}),(0,n.jsx)(t.annotation,{encoding:"application/x-tex",children:"[-1, 1]"})]})})}),(0,n.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(t.span,{className:"base",children:[(0,n.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(t.span,{className:"mopen",children:"["}),(0,n.jsx)(t.span,{className:"mord",children:"\u2212"}),(0,n.jsx)(t.span,{className:"mord",children:"1"}),(0,n.jsx)(t.span,{className:"mpunct",children:","}),(0,n.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(t.span,{className:"mord",children:"1"}),(0,n.jsx)(t.span,{className:"mclose",children:"]"})]})})]})," as ",(0,n.jsx)(t.strong,{children:"AVL invariant"})]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"AVL have the same methods as the BST do, but need more about keep balanced"}),"\n",(0,n.jsx)(t.h2,{id:"implement",children:"Implement"}),"\n",(0,n.jsx)(t.p,{children:"To have AVL Tree, we should modify the implement of BST."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Insert:"})," The same insert with modify the height of node to track if balance factor. After insert, check the AVL invariant if satisfied. If not, then we need to do rebalance/rotation."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Delete"}),": The same delete with modify the height of node to track if balance factor. After delete, check the AVL invariant if satisfied. If not, then we need to do rebalance/rotation."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Rebalance:"})," base on balance factor negative or not, we will swap left/right children with parent; more specifically, we have 4 cases  after insert/delete:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"insert/delete right, then left tree's right's height > left tree's left's: rotate left about left tree and then rotate right about root"}),"\n",(0,n.jsx)(t.li,{children:"left tree's right's height <= left tree's left's: rotate right about root"}),"\n",(0,n.jsx)(t.li,{children:"insert/delete left,  then right tree's left's height > right tree's right's: rotate right about right tree and then rotate left about root"}),"\n",(0,n.jsx)(t.li,{children:"right tree's left's height <= tree's right's: rotate left about root"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Rotation:"})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"rotate left: swap root with right tree where root new right = right tree's left and right tree's left = root;"}),"\n",(0,n.jsx)(t.li,{children:"rotate right: swap root with left tree where root new left = right tree's right and left tree's right = root;"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Code in python given in lec:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"AVL-INSERT(root, x):\n    if root is NIL:  # found insertion point\n        root = TreeNode(x)  # initial height = 0\n    elif x.key < root.item.key:\n        root.left = AVL-INSERT(root.left, x)\n        root = AVL-REBALANCE-RIGHT(root)\n    elif x.key > root.item.key:\n        root.right = AVL-INSERT(root.right, x)\n        root = AVL-REBALANCE-LEFT(root)\n    else:  # x.key == root.item.key\n        # Just replace root's item with x -- nothing else changes.\n        root.item = x\n        return root\n\nAVL-REBALANCE-LEFT(root):  # Precondition: root is not NIL\n    # Recalculate height.\n    root.height = 1 + max(root.left.height, root.right.height)\n    # Rebalance if necessary.\n    if root.right.height > 1 + root.left.height:\n        # Perform double rotation if necessary.\n        if root.right.left.height > root.right.right.height:\n            root.right = AVL-ROTATE-RIGHT(root.right)\n            root = AVL-ROTATE-LEFT(root)\n            return root\n\nAVL-REBALANCE-RIGHT(root):  # Precondition: root is not NIL\n    # Recalculate height\n    root.height = 1 + max(root.left.height, root.right.height)\n    # Rebalance if necessary.\n    if root.left.height > 1 + root.right.height:\n        # Perform double rotation if necessary.\n        if root.left.right.height > root.left.left.height:\n            root.left = AVL-ROTATE-LEFT(root.left)\n            root = AVL-ROTATE-RIGHT(root)\n            return root\n        \nAVL-ROTATE-LEFT(parent): # Precond: parent != NIL, parent.right != NIL\n    # Rearrange references.\n    child = parent.right\n    parent.right = child.left\n    child.left = parent\n    # Update heights.\n    parent.height = 1 + max(parent.left.height, parent.right.height)\n    child.height = 1 + max(child.left.height, child.right.height)\n    # Return new parent.\n    return child\n\nAVL-ROTATE-RIGHT(parent): # Precond: parent != NIL, parent.left != NIL\n    # Rearrange references.\n    child = parent.left\n    parent.left = child.right\n    child.right = parent\n    # Update heights.\n    parent.height = 1 + max(parent.left.height, parent.right.height)\n    child.height = 1 + max(child.left.height, child.right.height)\n    # Return new parent.\n    return child\n\nAVL-DELETE(root, x):\n    if root is NIL:\n        pass  # nothing to remove\n    elif x.key < root.item.key:\n        root.left = AVL-DELETE(root.left, x)\n        root = AVL-REBALANCE-LEFT(root)  # careful with direction!\n    elif x.key > root.item.key:\n        root.right = AVL-DELETE(root.right, x)\n        root = AVL-REBALANCE-RIGHT(root)  # careful with direction!\n    else:  # x.key == root.item.key\n        if root.left is NIL:\n            root = root.right  # includes case root.right is NIL\n        elif root.right is NIL:\n            root = root.left\n        else:\n            # Select whether to replace root.item with its predecessor or\n            # its successor, depending on the heights of subtrees.\n            if root.left.height > root.right.height:\n                root.item, root.left = AVL-DELETE-MAX(root.left)\n            else:\n                root.item, root.right = AVL-DELETE-MIN(root.right)\n                # Height might have changed, but no rebalancing for root.\n                root.height = 1 + max(root.left.height, root.right.height)\n                return root\n\nAVL-DELETE-MIN(root):\n    if root.left is NIL:\n        return root.item, root.right\n    else:\n        item, root.left = AVL-DELETE-MIN(root.left)\n        root = AVL-REBALANCE-LEFT(root)\n        return item, root\n\nAVL-DELETE-MAX(root):\n    if root.right is NIL:\n        return root.item, root.left\n    else:\n        item, root.right = AVL-DELETE-MAX(root.right)\n        root = AVL-REBALANCE-RIGHT(root)\n        return item, root\n\n\nAVL-SEARCH(root, k):\n    if root is NIL:  # k not in root's subtree\n        pass  # NIL will be returned below\n    elif k < root.item.key:\n        root = AVL-SEARCH(root.left, k)\n    elif k > root.item.key:\n        root = AVL-SEARCH(root.right, k)\n    else:  # x.key == root.item.key\n        pass  # root is the node we want\n    return root\n"})}),"\n",(0,n.jsx)(t.h2,{id:"worst-case-time-complexity",children:"Worst-Case Time Complexity"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"Operation"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"Time Complexity"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"Search"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"Insert"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"Delete"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"})]})]})]})]})}function d(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>l,a:()=>s});var n=r(7294);const o={},i=n.createContext(o);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);