"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3762],{7748:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"basics/0  C++","title":"Some C++ features","description":"- explicit keyword is used to prevent implicit conversion and copy-initialization. A quick example is that class with only one parameter constructor can be used as a type conversion. The following example","source":"@site/docs/basics/0  C++.md","sourceDirName":"basics","slug":"/basics/0  C++","permalink":"/docs/basics/0  C++","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Basic","permalink":"/docs/category/basic"},"next":{"title":"Function","permalink":"/docs/basics/Function"}}');var t=i(4848),o=i(8453);const r={},c="Some C++ features",l={},a=[];function d(e){const n={code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"some-c-features",children:"Some C++ features"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"explicit"})," keyword is used to prevent implicit conversion and copy-initialization. A quick example is that class with only one parameter constructor can be used as a type conversion. The following example"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class Foo {\r\nprivate:\r\n    int x_;\r\npublic:\r\n    Foo(int x) : x_(x) {}\r\n    int get() const { return x_; }\r\n};\r\n\r\nvoid printFoo(Foo foo) {\r\n    cout << foo.get() << endl;\r\n}\r\n\r\nint main(){\r\n    printFoo(10); // might work without explicit\r\n    return 0;\r\n};\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"virtual"})," keyword allow polymorphism aka let child class override parent class's method."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"cin << str"}),"\u7684\u6807\u51c6\u5199\u6cd5\u5e94\u8be5\u4e3a",(0,t.jsx)(n.code,{children:"getline(cin, str)"}),", \u56e0\u4e3ac++11\u53ca\u4ee5\u524d\u7684\u6807\u51c6\u4e2diostream\u91cc\u6ca1\u6709\u5904\u7406string\u7684\u7c7b\u65b9\u6cd5\uff0c\u800c\u8fd9\u53e5\u8bdd\u80fd\u6210\u529f\u662f\u56e0\u4e3a\u8c03\u7528\u4e86string\u7c7b\u7684\u4e00\u4e2afriend method,"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"inline"})," keyword usage same as macro, but inline is type safe and can be debugged."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"~"})," is the destructor keyword, which is called when the object is destroyed. It is called when the object is out of scope, or when delete is called on a pointer to the object."]}),"\n",(0,t.jsx)(n.li,{children:"c++ has return value optimization and move semantics, which means that return by value (for container type) is not as expensive as it seems. The compiler will optimize the code to avoid copying the object."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"static"}),": static varible can be only initialized once, and be accessed by current file or function only. It is initialized when the program starts and destroyed when the program ends. It is shared by all instances of the class."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"extern"}),": extern is used to declare a global variable or function in another file. e.g. file1 has variable ",(0,t.jsx)(n.code,{children:"int x"}),", file2 wants to use x, then file2 should declare ",(0,t.jsx)(n.code,{children:"extern int x"}),"; before using it.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["sometimes we might see ",(0,t.jsx)(n.code,{children:'extern "C" void somefunction();'})," or ",(0,t.jsx)(n.code,{children:'extern "C++" void somefunction();'})," which is used to tell the compiler to use C or C++ linkage. C++ linkage is the default."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"::"}),"  : scope resolution operator. e.g. i have a global variable x, and a local variable x, then i can use ",(0,t.jsx)(n.code,{children:"::x"})," to access the global variable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"volatile"}),": volatile is used to tell the compiler that the variable can be changed by other programs or threads. So the compiler will not optimize the code that uses the variable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"mutable"}),": mutable is used to tell the compiler that the variable can be changed by const member functions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"const"})," in function declaration: const in function declaration means that the function will not change the object. e.g. ",(0,t.jsx)(n.code,{children:"int get() const { return x_; }"})]}),"\n",(0,t.jsxs)(n.li,{children:["return by value: some of return by value such as std::vector will be optimized since Return Value Optimization (RVO) or Move Semantics is used. So it is not as expensive as it seems. But for some others, they be copied by calling Copy Constructor. So it is expensive. e.g. ",(0,t.jsx)(n.code,{children:"std::string"})," will be copied."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["lambda function uses ",(0,t.jsx)(n.code,{children:"[]"})," to catch outer scope variable, it contains following cases:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[]"}),": does not use outer scope variable"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[=]"}),": copy all outer scope variable"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[&]"}),": reference all outer scope variable"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[x]"}),": copy variable ",(0,t.jsx)(n.code,{children:"x"})," from outer scope"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[&x]"}),": reference variable ",(0,t.jsx)(n.code,{children:"x"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[=, ...]"}),": ",(0,t.jsx)(n.code,{children:"..."})," usually be the ",(0,t.jsx)(n.code,{children:"&var"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"[&,...]"}),": ",(0,t.jsx)(n.code,{children:"..."})," usually be the ",(0,t.jsx)(n.code,{children:"var"}),"\r\n",(0,t.jsx)(n.code,{children:"decltype"}),": short for declare type, use for look up type"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);