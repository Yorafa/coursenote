"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5367],{7520:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>t,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"Operating Systems/07 Paging and Address Translation","title":"Paging and Address Translation","description":"We need relocation, but how we do it?","source":"@site/docs/Operating Systems/07 Paging and Address Translation.md","sourceDirName":"Operating Systems","slug":"/Operating Systems/07 Paging and Address Translation","permalink":"/docs/Operating Systems/07 Paging and Address Translation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Memory Management","permalink":"/docs/Operating Systems/06 Memory Management"},"next":{"title":"Principles and Policies for Memory Management","permalink":"/docs/Operating Systems/08 Principles and Policies for Memory Management"}}');var i=n(4848),l=n(8453);const r={},t="Paging and Address Translation",o={},d=[{value:"Hardware Support",id:"hardware-support",level:2},{value:"Paging",id:"paging",level:2},{value:"Support for Paging",id:"support-for-paging",level:3},{value:"Page Faults",id:"page-faults",level:3},{value:"example of address translation",id:"example-of-address-translation",level:4},{value:"More on Page Table",id:"more-on-page-table",level:3},{value:"Examples:",id:"examples",level:4},{value:"Problems on Page Table",id:"problems-on-page-table",level:2},{value:"Solution to Save Space",id:"solution-to-save-space",level:2},{value:"Segmented Paging",id:"segmented-paging",level:3},{value:"Two-Level Page Tables (Multi-Level Page Tables)",id:"two-level-page-tables-multi-level-page-tables",level:3},{value:"Example",id:"example",level:4},{value:"More types of Page Table",id:"more-types-of-page-table",level:3},{value:"Solution to Save Time",id:"solution-to-save-time",level:2},{value:"Translation Lookaside Buffer (TLB)",id:"translation-lookaside-buffer-tlb",level:3},{value:"more about memory allocation",id:"more-about-memory-allocation",level:2},{value:"Sharing",id:"sharing",level:3}];function h(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"paging-and-address-translation",children:"Paging and Address Translation"})}),"\n",(0,i.jsx)(s.p,{children:"We need relocation, but how we do it?"}),"\n",(0,i.jsx)(s.h2,{id:"hardware-support",children:"Hardware Support"}),"\n",(0,i.jsx)(s.p,{children:"Hardware provides relocation registers to support. It add relative address to process starting address to form real address and check that address generated is within limits of process's space. There are two relocation registers: base and limit"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"when process is assigned to CPU, load base register with start address of process"}),"\n",(0,i.jsx)(s.li,{children:"load limit register with last logical address of process"}),"\n",(0,i.jsxs)(s.li,{children:["on memory reference instruction such as load, store, add base to logical address and compare with limit","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"if (addr < base || addr >= base + limit) then trap to OS since illegal address"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"store base and limit for each process as part of the PCB"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"paging",children:"Paging"}),"\n",(0,i.jsx)(s.p,{children:"recall some problems of partition:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"fixed partition: internal fragmentation and need overlays"}),"\n",(0,i.jsx)(s.li,{children:"dynamic partition: external fragmentation and managingavailable space"}),"\n",(0,i.jsxs)(s.li,{children:["processes must be allocated to contiguous blocks of physical memory, but","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"hard to figure out size of block"}),"\n",(0,i.jsx)(s.li,{children:"requirement of memory changing over time"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Paging is the solution."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Logically partition physical memory into equal, fixed-size chunks (",(0,i.jsx)(s.strong,{children:"page frames"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Divide process' memory into chunks of the same size (",(0,i.jsx)(s.strong,{children:"virtual pages"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["any virtual page can be assigned to any free page frame, which solve:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"no external fragmentation"}),"\n",(0,i.jsx)(s.li,{children:"Internal fragmentation is at most a fraction of one page per region"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"Possible page frame sizes are restricted to powers of 2 to simplify address translation"}),"\n",(0,i.jsxs)(s.li,{children:["Pages can be moved between memory and disk (",(0,i.jsx)(s.strong,{children:"demand paging"}),", method of memory management)"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Paging simplies virtualization of memory where:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"process doesn't need to use a contiguous region of physical memory"}),"\n",(0,i.jsxs)(s.li,{children:["no more need for base and limit registers (",(0,i.jsx)(s.strong,{children:"page table"})," is used instead)","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page tables store the mapping of pages to frams. In other word, page table records which physical frame holds each page."}),"\n",(0,i.jsx)(s.li,{children:"CPU use one register to find the start of the page table in memory (page table base register or PTBR)"}),"\n",(0,i.jsx)(s.li,{children:"One page table entry per page"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"support-for-paging",children:"Support for Paging"}),"\n",(0,i.jsx)(s.p,{children:"We know there is a translation but where does it happen? Hardware (MMU) converts virtual address to physical address using the Page Table. OS maintains a page table for each process."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The logical address are basically ",(0,i.jsx)(s.strong,{children:"page number + page offset"})," (here + not mean add instead it's concating) where:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page number = logical address / page size (first n bits of logical address)"}),"\n",(0,i.jsx)(s.li,{children:"page offset = logical address % page size (last m bits of logical address)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["on each memory reference, processor translates the page number to its frame number and adds the offset to generate a physical address. ",(0,i.jsx)(s.strong,{children:"physical address = frame number + page offset"})," (concat again)","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"frame number = page table[page number], frame number should keep the length of the page size"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"OS uses main memory as page cache of all data allocated in the system."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"initially, all pages are allocated from memory"}),"\n",(0,i.jsx)(s.li,{children:"when memory is full, allocating a page in memory requires some other page to be evicted from momory to disk (replacement with page on the disk, whole movement is done by OS and transparent to the application)"}),"\n",(0,i.jsx)(s.li,{children:"OS keep track of use of each physical frame"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"page-faults",children:"Page Faults"}),"\n",(0,i.jsx)(s.p,{children:"As mentioned, page can be evicted from memory. What happens when a processes a page that been evicted?"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"when os evicts a page, the OS sets the PTE as invalid and stores the location of the page in the swap file in the PTE"}),"\n",(0,i.jsxs)(s.li,{children:["when the process tries to access the page, the invalid PTE will cause a trap (the ",(0,i.jsx)(s.strong,{children:"page fault"}),")"]}),"\n",(0,i.jsx)(s.li,{children:"trap will run OS page fault handler"}),"\n",(0,i.jsx)(s.li,{children:"handler uses the invalid PTE to located page in swap file"}),"\n",(0,i.jsx)(s.li,{children:"reads page into a physical frame, updates PTE to point to it"}),"\n",(0,i.jsx)(s.li,{children:"resume process"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"It's expensive to handling page faults which may require 2 disk accesses so that OS keeps some free pages so that allocations do not always cause evictions."}),"\n",(0,i.jsx)(s.p,{children:"There are two option of managing swap space:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["use raw disk partition:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"faster (skip file system) but requires disk reformat to resize"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["use ordinary large file in file system:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"more flexible (can grow if more swap space is needed) but swap file can become fragmented"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"In conclusion, when should the swap space be allocated/freed?"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"it can be done on process startup/shutdown: ensure every process has enough swap space but may waste space"}),"\n",(0,i.jsx)(s.li,{children:"it can be done on pageout/pagein: only allocate swap space when needed but may cause page fault during process startup"}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"example-of-address-translation",children:"example of address translation"}),"\n",(0,i.jsx)(s.p,{children:"suppose address are 16 bits(i.e. 16 numbers of 01), pages are 1024 bytes, and following page table:"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Page"}),(0,i.jsx)(s.th,{children:"Frame"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"B"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"1"}),(0,i.jsx)(s.td,{children:"F"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"2"}),(0,i.jsx)(s.td,{children:"7"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"3"}),(0,i.jsx)(s.td,{children:"1C"})]})]})]}),"\n",(0,i.jsx)(s.p,{children:"then we have:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page number = logical address / page size = 2^16 / 1024 = 2^6 or in binary 6 bits format, that is the first 6 bits of logical address"}),"\n",(0,i.jsx)(s.li,{children:"page offset = 2^10 or in binary 10 bits format, the rest 10 bits of logical address"}),"\n",(0,i.jsx)(s.li,{children:"frame number = page table[page number]"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"let's try 0x0DDE: first we have 0b0000 1101 1101 1110 for binary format, then we have:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page number = 0b0000 1101 1101 1110 / 2^10 = 0b0000 11 = 3"}),"\n",(0,i.jsx)(s.li,{children:"page offset = 0b0000 1101 1101 1110 % 2^10 = 0b01 1101 1110 = 0x1DE"}),"\n",(0,i.jsx)(s.li,{children:"frame number = page table[page number] = page table[3] = 0x1C"}),"\n",(0,i.jsx)(s.li,{children:"physical address = frame number + page offset = 0x1C + 0x1DE = 0b0111 00 (in page size) + 0b01 1101 1110 (in page offset) = 0b0111 0001 1101 1110 = 0x71DE"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"more-on-page-table",children:"More on Page Table"}),"\n",(0,i.jsx)(s.p,{children:"Generally for a 32 bits page table entry, we have: MRVRWX + Page Frame Number (26 bits)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"M(modified): if page has been written, set to 1"}),"\n",(0,i.jsx)(s.li,{children:"R(referenced): if page has been read or write, set to 1"}),"\n",(0,i.jsx)(s.li,{children:"V(valid): if page is in memory(in use), set to 1"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"We know page tables are maintained by OS and stored in memory. But where exactly (which address space)?"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["When store in the physical memory we use direct mapping method (does not use TLB) which means the same address in virtual memory and physical memory.","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["not exactly the same, still need simple translation (e.g. on 32-bit machine, use virtual address to subtract ",(0,i.jsx)(s.code,{children:"0xC0000000"})," to get physical address)"]}),"\n",(0,i.jsx)(s.li,{children:"it simplifies hardware support but consume memory for lifetime of virtual address space"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"when store in the virtual memory: unused (cold) page table pages can be paged out to disk so that addressing page table may requires translation. (We don't page the outer page table to aviod recursive page table)"}),"\n",(0,i.jsx)(s.li,{children:"that's combine both, we have a wire page table in memory, the rest can be physical or virtual memory"}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"examples",children:"Examples:"}),"\n",(0,i.jsx)(s.p,{children:"for a process with 32 bits vitrual address space with 4kb pages:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page number = 32 - 12 = 20 bits which implies totaly 2^20 pages which also means there are 2^20 entries in page table"}),"\n",(0,i.jsx)(s.li,{children:"page offset = 12 bits"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"If 4 bytes per page table entry, then page table size is 2^20 * 4 = 1MB * 4 = 4MB"}),"\n",(0,i.jsx)(s.p,{children:"If there are 25 processes, then total memory is 25 * 4MB = 100MB"}),"\n",(0,i.jsx)(s.h2,{id:"problems-on-page-table",children:"Problems on Page Table"}),"\n",(0,i.jsx)(s.p,{children:"What is the virtual address is 48 bits? Then we have:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page number = 48 - 12 = 36 bits which implies totaly 2^36 pages which also means there are 2^36 entries in page table"}),"\n",(0,i.jsx)(s.li,{children:"page offset = 12 bits"}),"\n",(0,i.jsx)(s.li,{children:"page table size is 2^36 * 4 = 2^30 * 2^6 * 4 = 1GB * 256 = 256GB for 4 bytes per page table entry"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"How can we reduce the size of page table? One approach is to enlarge the page size. For example use 16KB page size, then we have:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page number = 48 - 14 = 34 bits which implies totaly 2^34 pages which also means there are 2^34 entries in page table"}),"\n",(0,i.jsx)(s.li,{children:"page table size is 2^34 * 4 = 2^30 * 2^4 * 4 = 1GB * 64 = 64GB for 4 bytes per page table entry"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"That is, we found the problem here that the small process with large page table"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"for example a process with 1KB memory, then we have 4kb page size which will waste 3KB memory"}),"\n",(0,i.jsx)(s.li,{children:"and even worse for page table size"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"solution-to-save-space",children:"Solution to Save Space"}),"\n",(0,i.jsx)(s.h3,{id:"segmented-paging",children:"Segmented Paging"}),"\n",(0,i.jsx)(s.p,{children:"Segmented paging is a combination of segmentation and paging. It is a way to reduce the size of page table. The idea is to divide the virtual address space into segments and then divide each segment into pages. But:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page table base and limit registers per segment"}),"\n",(0,i.jsx)(s.li,{children:"Limit number of regions which is inflexible"}),"\n",(0,i.jsxs)(s.li,{children:["still waste on external fragmentation","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page tables can be arbitrary size and requires contiguity but find free space get complicated"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"two-level-page-tables-multi-level-page-tables",children:"Two-Level Page Tables (Multi-Level Page Tables)"}),"\n",(0,i.jsx)(s.p,{children:"By using two-level page tables, the virtual address is changed to: Page Directory Number + Page Table Number + Page Offset (again concat):"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page directory maps virtural page number to second-level page table and second-level page table maps virtual page number to page frame number"}),"\n",(0,i.jsx)(s.li,{children:"Page Directory Base Pointer (PDBR) is a register that points to the page directory"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"For multi-level page tables, please read clearly the instruction."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["we can have table -> table -> ... -> table -> pte, but table size and pte size are different","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"e.g. For a 4-level table, using 9 bits to index each level, 8-byte pointers for the entry at each level, and 12 bytes for the PTE at the bottom, you need 4096 bytes for a table at each level, and 6144 bytes for each table at the bottom level.\xa0"}),"\n",(0,i.jsx)(s.li,{children:"but sometimes, we also may have using 9 bits to index each level, 8-byte pointers for the entry and additional 4-byte for additional info at each level, and 12 bytes for the PTE at the bottom, you need 6144 bytes for a table at each level, and 6144 bytes for each table at the bottom level."}),"\n",(0,i.jsx)(s.li,{children:"the best case is that, all 8-byte pointers use."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["normally, 32 bit virtual memory system use 4-byte pte and 4kb page size","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"4-byte pte means 32 bits number"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"example",children:"Example"}),"\n",(0,i.jsx)(s.p,{children:"32 bits virtual address space with 4kb page size, 4 bytes per page table entry, then we have:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page offset = 12 bits (same as before, the rest 12 bits of logical address from 4kb = 2^12)"}),"\n",(0,i.jsx)(s.li,{children:"Page Directory Number = 4kb / 4 bytes = 2^10 = 10 bits (why? since 4 bytes per page table entry and we have 4 kb page size, which means 2^10 entries in page table)"}),"\n",(0,i.jsx)(s.li,{children:"Page Table Number = 20(the remain 20 bits) - 10 = 10 bits"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"even further, we can Multi-Level page tables, for example for a 48 bits virtual address space with 4kb page size, 8 bytes per page table entry, then we have:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page offset = 12 bits (same as before, the rest 12 bits of logical address from 4kb = 2^12)"}),"\n",(0,i.jsx)(s.li,{children:"bits per levels = 4kb / 8 bytes = 2^9 = 9 bits"}),"\n",(0,i.jsx)(s.li,{children:"36/9 = 4 levels"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"what if we dont have a specific pte size(normally no such situation exist, here for more understanding)? e.g. 32 bits virtual address space with 4kb page size, 5 level, then we have:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"page offset = 12 bits (same as before, the rest 12 bits of logical address from 4kb = 2^12)"}),"\n",(0,i.jsx)(s.li,{children:"table size per level = 20 / 5 = 4 bits"}),"\n",(0,i.jsx)(s.li,{children:"pte size = 2^12 / 2^4 = 2^8 = 256 bytes (why? since we want use all page? too big what we use for lolllll)"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"more-types-of-page-table",children:"More types of Page Table"}),"\n",(0,i.jsx)(s.p,{children:"Hashed Page Tables: hash function maps virtual page number to bucket in fixed-sized hash table"}),"\n",(0,i.jsx)(s.p,{children:"Inverted Page Tables: keep one table with an entry for each physical page frame where entry records which virtual page # is stored in that frame and process id. That is reference uses virtual addresses, table is indexed by physical address."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["less space but slower lookup","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"can use hash to reduce the search time"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"map keeps track of state of physical frames, can do fast allocation of physical frame and not used for address translation"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"solution-to-save-time",children:"Solution to Save Time"}),"\n",(0,i.jsx)(s.p,{children:"Although paging is a good solution to save space, it also has some problems."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"memory reference time overhead, at least 2 memory references per access (worse for hierarchical page tables)"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"translation-lookaside-buffer-tlb",children:"Translation Lookaside Buffer (TLB)"}),"\n",(0,i.jsx)(s.p,{children:"We can use hardware cache of lookups to save time. Further, TLB is:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"small, fully associative cache of page table entries (all entries looked up in parallel)"}),"\n",(0,i.jsx)(s.li,{children:"part of MMU,"}),"\n",(0,i.jsx)(s.li,{children:"translates virtual pages into PTEs that can be done in a single machine cycle."}),"\n",(0,i.jsxs)(s.li,{children:["TLB store TAG + PTE, where","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Tages are virtual page numbers"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"There are two situation uses TLB (i.e. places needed address translation into the TLB):"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["hardware-loaded (MMU)","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Tables must be in hardware-defined format."}),"\n",(0,i.jsx)(s.li,{children:"MMU knows where page tables are in main memory (PTBR) and OS maintains page tables in main memory. Hardware accesses them directly."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Software-loaded (OS)","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Tables can be in any format convenient to OS"}),"\n",(0,i.jsxs)(s.li,{children:["TLB faults to OS, OS finds appropriate page table, loads into TLB","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Some situation like TLB misses and a new PTE must be loaded, then a cached PTE must be evicted to make room for new PTE. (i.e. TLB replacement policy, implemented in hardware)"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"must be fast (but still 20-200 cycles)"}),"\n",(0,i.jsx)(s.li,{children:"CPU ISA(Instruction Set Architecture) has instructions for manipulating TLB (i.e. add, read, invalidate, flush (invalidate all), etc.)"}),"\n",(0,i.jsx)(s.li,{children:"OS ensure that TLB and Page Table are consistent (i.e. invalidate the TLB entry when page table entry's protection bits is changed)"}),"\n",(0,i.jsx)(s.li,{children:"Reload TLB on a process context switch (i.e. flush TLB), which is expensive"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"more-about-memory-allocation",children:"more about memory allocation"}),"\n",(0,i.jsx)(s.p,{children:"We allocate memory for a process in two ways:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["fixed space algorithm:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"each process is given a limit of pages it can use"}),"\n",(0,i.jsx)(s.li,{children:"when it reaches the limit, it replaces from its own pages (local replacement)"}),"\n",(0,i.jsx)(s.li,{children:"processes may do well while others may suffer (unfair)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["variable space algorithms:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"process' set of pages grows and shrinks dynamically"}),"\n",(0,i.jsx)(s.li,{children:"can use global replacement: one process can ruin it for the rest"}),"\n",(0,i.jsx)(s.li,{children:"or local replacement: replacement and set size are separate"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"sharing",children:"Sharing"}),"\n",(0,i.jsx)(s.p,{children:"When we introduce about process, we know that private virtual address spaces protect applcation from each other. We also know we can use some system call to share memory between processes. How can we implement it using paging?"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["have PTEs in both tables map to the same physical frame, but its virtual address can differ or not","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"if different: flexible but pointer inside the shared memory segement are invalid (i.e. pointer uses virtual address)"}),"\n",(0,i.jsx)(s.li,{children:"if same: less flexible but shared pointers are valid."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"each PTE can have different protection values"}),"\n",(0,i.jsx)(s.li,{children:"must update both PTEs when page become invalid"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"We also use copy-on-write to save memory. The idea is to share pages between parent and child processes until one of them writes to the page. Then the page is copied and the processes are no longer sharing the page."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["shared pages are marked read-only","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Writes generate a protection fault, trap to OS, then copy page, change page mapping in page table, enable write permission, restart write instruction"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"fork()"})," system call makes copy of process including virtual address space (no copy-on-write)"]}),"\n"]})]})}function c(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>t});var a=n(6540);const i={},l=a.createContext(i);function r(e){const s=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(l.Provider,{value:s},e.children)}}}]);