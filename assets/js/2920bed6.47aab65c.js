"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[643],{3656:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Operating Systems/06 Memory Management","title":"Memory Management","description":"Process address space layout","source":"@site/docs/Operating Systems/06 Memory Management.md","sourceDirName":"Operating Systems","slug":"/Operating Systems/06 Memory Management","permalink":"/docs/Operating Systems/06 Memory Management","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Scheduling","permalink":"/docs/Operating Systems/05 Scheduling"},"next":{"title":"Paging and Address Translation","permalink":"/docs/Operating Systems/07 Paging and Address Translation"}}');var t=n(4848),r=n(8453);const a={},l="Memory Management",o={},d=[{value:"Address Binding",id:"address-binding",level:2},{value:"Compile time binding",id:"compile-time-binding",level:3},{value:"Load time binding",id:"load-time-binding",level:3},{value:"Execution time binding",id:"execution-time-binding",level:3},{value:"Partition of Physical Memory",id:"partition-of-physical-memory",level:2},{value:"Placement Algorithms",id:"placement-algorithms",level:3},{value:"Virtual Memory",id:"virtual-memory",level:2}];function c(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"memory-management",children:"Memory Management"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Process address space layout",src:n(6200).A+"",width:"469",height:"452"})}),"\n",(0,t.jsx)(s.p,{children:"As we introduced before, process use virtual(logical) address space, and the OS generates logical address in this space as the program executes. Memory system must see physical address, that is, we have Memory Management Unit(MMU) to translate logical address to physical address. Physical memory must be allocated for every virtual address used by the program."}),"\n",(0,t.jsx)(s.p,{children:"What else Memory Management does?"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"every active process must be allocated memory"}),"\n",(0,t.jsx)(s.li,{children:"CPU scheduling that allows processes to share the CPU, and memory management must figure out how to share memory among processes"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"A good memory management should be:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"support enough active processes to keep CPU busy"}),"\n",(0,t.jsx)(s.li,{children:"Use memory efficiently"}),"\n",(0,t.jsx)(s.li,{children:"Keep memory management overhead small"}),"\n",(0,t.jsxs)(s.li,{children:["Statisfied 5 requirements of memory management:","\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Relocation:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"programmer should not know what physical memory will be available at execution time"}),"\n",(0,t.jsx)(s.li,{children:"Long-term scheduler may swap processes in and out of memory"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.li,{children:"Protection: A process's memory should be protected from unwanted access by other processes, both intentional and accidental"}),"\n",(0,t.jsx)(s.li,{children:"Sharing: processes may access the same memory so that need ways to specify and control what sharing is allowed"}),"\n",(0,t.jsxs)(s.li,{children:["Logical organization:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Machine addresses memory as a linear array of bytes"}),"\n",(0,t.jsx)(s.li,{children:"Programmers organize code and data in separate logical regions"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["Physical organization:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Memory and disk form a two-level hierarchy where flow of information between levels must be managed"}),"\n",(0,t.jsx)(s.li,{children:"CPU can only access data in registers or memory, not disk"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"address-binding",children:"Address Binding"}),"\n",(0,t.jsx)(s.h3,{id:"compile-time-binding",children:"Compile time binding"}),"\n",(0,t.jsx)(s.p,{children:"We must know during compilation what memory lcoations the process will use when it executes. That is,"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"we have absolute code since binary contains real address,"}),"\n",(0,t.jsx)(s.li,{children:"No relocation is possible which means cannot run more than one instance of program, since"}),"\n",(0,t.jsx)(s.li,{children:"programs must be loaded at exact address specified during compilation,"}),"\n",(0,t.jsx)(s.li,{children:"Overwrites (evicts) any program already located at those addresses"}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"load-time-binding",children:"Load time binding"}),"\n",(0,t.jsx)(s.p,{children:"Compiler translates symbolic address to logical, relocatable address within compilation unit(source file). Linker takes collection of object files and translates adresses to logical, absolute addresses within executable."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"resolves references to symbols defined in other files/modules"}),"\n",(0,t.jsx)(s.li,{children:"executable file includes relocation table, which identifies all the address that need to be translated at load time,"}),"\n",(0,t.jsx)(s.li,{children:"load time is when program is loaded into memory"}),"\n",(0,t.jsx)(s.li,{children:"Programs can be loaded to different address when they start, but cannot be relocated later."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"execution-time-binding",children:"Execution time binding"}),"\n",(0,t.jsx)(s.p,{children:"Executable object file contains logical addresses for entire program and translated to a real, physical address during execution."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Flexible but requires special hardware support"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"partition-of-physical-memory",children:"Partition of Physical Memory"}),"\n",(0,t.jsx)(s.p,{children:"Memory is divided into region with fixed boundaries that can be equal-size or unequal-size. OS occupies one partition and a single process can be loaded into each remaining partition."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Memory is wasted if process is smaller than partition"}),"\n",(0,t.jsxs)(s.li,{children:["programmer must deal with programs that are larger than partition","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Use overlay to allow process to be larger than partition, but requires manual memory management. explicitly unload parts of program code or data that are no longer needed and load parts that are need next."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Equal-sized partitions allow process to be loaded into any available partition."}),"\n",(0,t.jsx)(s.p,{children:"There are two cases (queue-per-partition and single queue) for unequal-sized partitions, they both assign process to smallest available partition, but in:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"queue-per-partition (i.e. different queue with different processes): a process always runs in same partition size"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Some possible issues are that:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"the number of partitions determines number of active processes (not efficient). If all partitions are allocated to processes that are waiting, we can swap some processes out to disk to make room in memory and either admit new runnable processes or swap in previously evicted processes that have become runnable"}),"\n",(0,t.jsx)(s.li,{children:"Number of partitions is decided at system configuration time (boot time) which means not adjustable"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"What if we have dynamic partition? We divide memory vary in length and number over time. When a process is brought into memory, a partition of exactly thr right size is created to hold the process. But it leads some problems:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["as processes come and go, memory may be a hole there that no one can use (i.e. previous process and the next process are not done yet, but the hole is too small for the next process) which is called ",(0,t.jsx)(s.strong,{children:"external fragmentation"})]}),"\n",(0,t.jsxs)(s.li,{children:["OS may move processes around to create larger chunks of free space to solve external fragmentation which need processes to be relocatable which is called ",(0,t.jsx)(s.strong,{children:"compaction"}),". Compaction is time-consuming.","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"we can reduce the need by careful about how memory is allocated to processes over time"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.li,{children:"need tto know maximum size of process at load time"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"malloc()/free()"})," implemented in C library is the dynamic partitioning system without relocation."]}),"\n",(0,t.jsx)(s.h3,{id:"placement-algorithms",children:"Placement Algorithms"}),"\n",(0,t.jsx)(s.p,{children:"Here multiple blocks of free memory of sufficient size, how do we choose? There are:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["First-fit: allocate first hole that is big enough (search from beginning)","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"simplest and often fastest and most efficient"}),"\n",(0,t.jsx)(s.li,{children:"leaves small fragments near start of memory that must be searched through repeatedly"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["Next-fit: allocate next hole that is big enough (search from where previous search ended)","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Tends to allocate from end of memory"}),"\n",(0,t.jsx)(s.li,{children:"free space becomes fragmented more rapidly"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["Best-fit: allocate the closest in size to request (search entire list)","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"left-over fragments tend to be small"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.li,{children:"Worst-fit: choose the largest hole (search entire list)"}),"\n",(0,t.jsxs)(s.li,{children:["Quick-fit: keep multiple free lists for common block sizes","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"great for fast allocation, generally harder to coalesce free blocks"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"virtual-memory",children:"Virtual Memory"}),"\n",(0,t.jsx)(s.p,{children:"Each process has its own virtual address space. Virtual address space contains regions with different modes."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["virtual address space as a view to memory, areas of it might not be mapped to physical memory (not allocated).","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Linux doesn't allocate physical memory until the first time it is used, that is no memory allocated when ",(0,t.jsx)(s.code,{children:"malloc()"}),", ",(0,t.jsx)(s.code,{children:"mmap()"})," or ",(0,t.jsx)(s.code,{children:"sbrk()"})," is called."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["to manage virtual memory better, virtual address space is divided into ",(0,t.jsx)(s.strong,{children:"virtual memory areas"})," (VMAs) which are contiguous regions of virtual address space with same properties (e.g. read-only, read-write, shared, etc.)","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"VMAs give a way to track space that the process expects to use and some policy associated with it."}),"\n",(0,t.jsxs)(s.li,{children:["Initial VMAs are created by the OS when process is created (i.e. ",(0,t.jsx)(s.code,{children:"exec()"})," system call)"]}),"\n",(0,t.jsxs)(s.li,{children:["Additional VMAs can be created by the process itself (i.e. ",(0,t.jsx)(s.code,{children:"mmap()"})," system call)"]}),"\n",(0,t.jsx)(s.li,{children:"page fault handler checks VMAs first to see if the faulting address is valid (we will talk about page fault later)"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},6200:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/address space layout-fda46df8882efc88a1259fe059115d1a.png"},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var i=n(6540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);