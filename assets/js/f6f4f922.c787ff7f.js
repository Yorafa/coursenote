"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4084],{923:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var s=n(5893),t=n(1151);const l={},r="File System",o={id:"csc/csc369/09 file system introduction",title:"File System",description:"File system is used to virtualize persistent storage.",source:"@site/docs/csc/csc369/09 file system introduction.md",sourceDirName:"csc/csc369",slug:"/csc/csc369/09 file system introduction",permalink:"/docs/csc/csc369/09 file system introduction",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Principles and Policies for Memory Management",permalink:"/docs/csc/csc369/08 Principles and Policies for Memory Management"},next:{title:"File System Reliability",permalink:"/docs/csc/csc369/10 file system reliability"}},a={},c=[{value:"Conceptual File Operations",id:"conceptual-file-operations",level:2},{value:"Directories",id:"directories",level:2},{value:"File Links",id:"file-links",level:3},{value:"implementation of directories",id:"implementation-of-directories",level:3},{value:"Disk",id:"disk",level:2},{value:"More about Disk block",id:"more-about-disk-block",level:3},{value:"Step to access a file",id:"step-to-access-a-file",level:4},{value:"Problems and Solutions",id:"problems-and-solutions",level:3}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"file-system",children:"File System"}),"\n",(0,s.jsx)(i.p,{children:"File system is used to virtualize persistent storage."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"controls when and how data is transferred between memory and disk"}),"\n",(0,s.jsx)(i.li,{children:"save information after process exits"}),"\n",(0,s.jsx)(i.li,{children:"concurrent access to shared data by multiple processes"}),"\n",(0,s.jsx)(i.li,{children:"organize secondary storage abstraction (files) logically (directories)"}),"\n",(0,s.jsx)(i.li,{children:"protect data from unwanted access (security)"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"User view of file system: convenient logical organization of information"}),"\n",(0,s.jsx)(i.p,{children:"OS view of file system: managing physical storage media, enforcing access restriction."}),"\n",(0,s.jsx)(i.h2,{id:"conceptual-file-operations",children:"Conceptual File Operations"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"create: find space in fs and add entry to directory"}),"\n",(0,s.jsx)(i.li,{children:"write: overwrite or append to file"}),"\n",(0,s.jsx)(i.li,{children:"read: dominant abstraction (file is a stream)"}),"\n",(0,s.jsx)(i.li,{children:"reposition within file: changes current position within file for next read or write"}),"\n",(0,s.jsx)(i.li,{children:"delete: remove file from directory and free space"}),"\n",(0,s.jsx)(i.li,{children:"truncate: may erase the contents of a file while keeping the file"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"General-purpose file systems support simple methods"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Sequential access \u2013 read bytes one at a time, in order (e.g., tape, HDD)"}),"\n",(0,s.jsx)(i.li,{children:"Direct access \u2013 random access given block/byte number (e.g., SSD)"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"directories",children:"Directories"}),"\n",(0,s.jsx)(i.p,{children:"Directories provide a way to orgaanize files and also logical structure to the file system. It gives a convenient naming interface."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"separates logical file organization from physical file palcement on the disk."}),"\n",(0,s.jsx)(i.li,{children:"stores information about files (owner, permissions, etc.)"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"A directory is a list (usualy unordered) of entries (names and associated metadata) and it can implement as:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Lists:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"simle list of file names and pointers to data block"}),"\n",(0,s.jsx)(i.li,{children:"requires linear search to find entries"}),"\n",(0,s.jsx)(i.li,{children:"easy to implement, slow to execute but directory operations are frequent"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["Hash tables:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"create a list of file info structures"}),"\n",(0,s.jsx)(i.li,{children:"hash file name to get a pointer to the file info structure in the list"}),"\n",(0,s.jsx)(i.li,{children:"hash table takes space"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"file-links",children:"File Links"}),"\n",(0,s.jsx)(i.p,{children:"Sharing can be implemented by creating a new directory entry called a link: a pointer to another file or subdirectory. And we have two types of links:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Hard links","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Second directory entry identical to the first, add a link count to the inode"}),"\n",(0,s.jsxs)(i.li,{children:["can use ",(0,s.jsx)(i.code,{children:"ln"})," to create a hard link"]}),"\n",(0,s.jsx)(i.li,{children:"a file will be deleted only when all links to it are deleted (i.e link count = 0)"}),"\n",(0,s.jsx)(i.li,{children:"all children directories point to the parent directory, that is, the link count = # of children + 1 (parent to here) + 1 (one to self) + hard links"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["Symbolic link (soft link)","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:'Directory entry refers to file that holds "true" path to the linked file'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"pros and cons for hard links and soft links:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Hard links"}),(0,s.jsx)(i.th,{children:"Soft links"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"can't link to directories (avoid cycle)"}),(0,s.jsx)(i.td,{children:"can link to files or directories"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"can't link across file systems"}),(0,s.jsx)(i.td,{children:"can link across file systems"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"No extra processing on access"}),(0,s.jsx)(i.td,{children:"needs look up the link"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"remove target file link count -= 1, delete when count = 0"}),(0,s.jsx)(i.td,{children:"remove target file lead to a dangling link"})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"implementation-of-directories",children:"implementation of directories"}),"\n",(0,s.jsx)(i.p,{children:"Directories are implemented as files with special format."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"simplest: array of fixed-size entries"}),"\n",(0,s.jsx)(i.li,{children:"list of variable length entries"}),"\n",(0,s.jsx)(i.li,{children:"hash table or b-tree"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"disk",children:"Disk"}),"\n",(0,s.jsx)(i.p,{children:"Disks are block access device and file systems uses blocks. We need a strategy to store which disk blocks belong to which files."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"contiguous allocation: store all blocks of a file together"}),"\n",(0,s.jsxs)(i.li,{children:["linked allocation: store blocks of a file anywhere on disk, but keep a linked list of blocks","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"if a data block is corrupted, could lose the rest of the file"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["indexed allocation: all file metadata in one place (inode). Each inode contains 15 block pointers:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"first 12 are direct block pointers: Disk addresses of the first 12 data blocks in the file"}),"\n",(0,s.jsx)(i.li,{children:"13th is a single (or just) indirect block pointer: Disk address of a block that contains disk addresses of data blocks (i.e. a block of block pointers)"}),"\n",(0,s.jsx)(i.li,{children:"14th is a double indirect block pointer: Disk address of a block that contains disk addresses of blocks that contain disk addresses of data blocks"}),"\n",(0,s.jsx)(i.li,{children:"15th is a triple indirect block pointer"}),"\n",(0,s.jsx)(i.li,{children:"cost of access to bytes near the end of large files grows"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["extent-based allocation: ",(0,s.jsx)(i.strong,{children:"extent"})," is defined as a disk pointer and a length.","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"it allocates a contiguous set of blocks for a file. (start, length) tuples are used instead of pointers to every block"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["link-based allocation: instead of pointer to all blocks, use pointer to point first block and first to second, second to third, etc. (i.e. a linked list of blocks) and also track tail pointer to suppport append operation","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"use file allocation table (FAT) to track next block of a file"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"pros and cons for contiguous allocation, linked allocation and indexed allocation:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"contiguous allocation"}),(0,s.jsx)(i.th,{children:"linked allocation"}),(0,s.jsx)(i.th,{children:"indexed allocation"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"fast sequential access"}),(0,s.jsx)(i.td,{children:"easy sequential access, but direct access expensive"}),(0,s.jsx)(i.td,{children:"fast sequential access and random access"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"allocation/deallocation fast"}),(0,s.jsx)(i.td,{children:"normal"}),(0,s.jsx)(i.td,{children:"normal"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"external fragmentation so compaction needed"}),(0,s.jsx)(i.td,{children:"no external fragmentation"}),(0,s.jsx)(i.td,{children:"no external fragmentation"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"inflexible (move file)"}),(0,s.jsx)(i.td,{children:"flexible"}),(0,s.jsx)(i.td,{children:"flexible"})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"more-about-disk-block",children:"More about Disk block"}),"\n",(0,s.jsxs)(i.p,{children:["We define the minimuim disk block size as ",(0,s.jsx)(i.strong,{children:"sector size"}),". The transfer of data between disk and memory is always a block of data."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"although block size usually defined by the file system, but must be a multiple of the sector size"}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["We use a ",(0,s.jsx)(i.strong,{children:"superblock"})," to holds metadata about the overall file system so that it can be identitfied on disk."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"superblock at a well-know disk location"}),"\n",(0,s.jsx)(i.li,{children:"identifies type of file system"}),"\n",(0,s.jsx)(i.li,{children:"includes location of other metadata, file system size, etc"}),"\n",(0,s.jsx)(i.li,{children:"often replicated for reliability"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"We also have a free map to tracks which blocks are free."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"it's usually a bitmap, one bit per block on the disk where ith bit correspond to block i"}),"\n",(0,s.jsx)(i.li,{children:"1 means block is free, 0 means block is allocated"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"The remain block are used to store files and directories (and other file system metadata). And file system needs to track information about those."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"in most file systems, directories are just a type of files and its contents are just a list of directory entries"}),"\n",(0,s.jsxs)(i.li,{children:["such information is stored in a ",(0,s.jsx)(i.strong,{children:"inode"})," (index node) data structure"]}),"\n",(0,s.jsx)(i.li,{children:"There is also a inode table is an array of inodes which stored in consecutive blocks on disk. such table allocated when file system is created so that maximum files is pre-determined."}),"\n",(0,s.jsx)(i.li,{children:"inode bitmap also used to track which inodes are free"}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:"step-to-access-a-file",children:"Step to access a file"}),"\n",(0,s.jsx)(i.p,{children:'for a file, "/a", we need to:'}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:'find root directory inode "/" (known location from system headfile or superblock and get from inode table)'}),"\n",(0,s.jsx)(i.li,{children:"read the root directory inode to find the data blocks that hold the directory entries of the root directory"}),"\n",(0,s.jsx)(i.li,{children:"read the first data block for the directory entries"}),"\n",(0,s.jsx)(i.li,{children:'search data blocks until find the directory entry for "a"'}),"\n",(0,s.jsx)(i.li,{children:'the entry for "a" is a pointer to the inode for "a"'}),"\n",(0,s.jsx)(i.li,{children:'read the inode for "a"'}),"\n",(0,s.jsx)(i.li,{children:"find the data blocks"}),"\n",(0,s.jsx)(i.li,{children:"read the data blocks into memory to access the file"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"problems-and-solutions",children:"Problems and Solutions"}),"\n",(0,s.jsx)(i.p,{children:"The most common problems for a very simple file system are:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"long seek time"}),"\n",(0,s.jsx)(i.li,{children:"fragmentation"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Some solutions are:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["allocation groups(also known as Cylinder groups) used by FFS","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"to fix fragmentation (enhance placement), we divide the disk into groups of consecutive blocks called allocation groups"}),"\n",(0,s.jsx)(i.li,{children:"inode for file and file's data blocks in the same allocation group"}),"\n",(0,s.jsx)(i.li,{children:"also the files in the same directory are in the same allocation group"}),"\n",(0,s.jsx)(i.li,{children:"reduce seek time but need additional free space to allocate according to allocation groups (normally 10%)"}),"\n",(0,s.jsx)(i.li,{children:"a large file may break it into large chunks and allocate from different allocation groups"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["master file table (MFT) used by NTFS:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"similar feature as the inode table, divide disk into blocks and each block contains a list of entries"}),"\n",(0,s.jsx)(i.li,{children:"each entry is a sequence of variable length pairs (attribute type, attribute value)"}),"\n",(0,s.jsx)(i.li,{children:"long attributes may stored externally, but a pointer used to point it in the entry"}),"\n",(0,s.jsx)(i.li,{children:"large directory use B+ tree to store entries in this kind of file system"}),"\n",(0,s.jsx)(i.li,{children:"reduce seek time but more space"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,i,n)=>{n.d(i,{Z:()=>o,a:()=>r});var s=n(7294);const t={},l=s.createContext(t);function r(e){const i=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);