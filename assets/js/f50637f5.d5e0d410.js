"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1775],{4580:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"Algorithm & Data Structure/csc263/AVL Tree","title":"AVL Tree","description":"A tree is an AVL Tree if it is binary search tree and AVL balanced.","source":"@site/docs/Algorithm & Data Structure/csc263/AVL Tree.md","sourceDirName":"Algorithm & Data Structure/csc263","slug":"/Algorithm & Data Structure/csc263/AVL Tree","permalink":"/docs/Algorithm & Data Structure/csc263/AVL Tree","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"CSC263 Data Structures and Analysis","permalink":"/docs/Algorithm & Data Structure/csc263/"},"next":{"title":"Amortized Analysis","permalink":"/docs/Algorithm & Data Structure/csc263/Amortized Analysis"}}');var o=r(4848),i=r(8453);const s={},a="AVL Tree",h={},l=[{value:"Implement",id:"implement",level:2},{value:"Worst-Case Time Complexity",id:"worst-case-time-complexity",level:2}];function c(e){const t={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"avl-tree",children:"AVL Tree"})}),"\n",(0,o.jsxs)(t.p,{children:["A tree is an ",(0,o.jsx)(t.strong,{children:"AVL Tree"})," if it is ",(0,o.jsx)(t.a,{href:"/docs/Algorithm%20&%20Data%20Structure/csc263/Binary%20Search%20Tree",children:"binary search tree"})," and AVL balanced."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"We first define the balance factor = #height of right subtree -  #height of left subtree"}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"AVL balanced"})," means that each node of this tree satisfied balance factor in range ",(0,o.jsxs)(t.span,{className:"katex",children:[(0,o.jsx)(t.span,{className:"katex-mathml",children:(0,o.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(t.semantics,{children:[(0,o.jsxs)(t.mrow,{children:[(0,o.jsx)(t.mo,{stretchy:"false",children:"["}),(0,o.jsx)(t.mo,{children:"\u2212"}),(0,o.jsx)(t.mn,{children:"1"}),(0,o.jsx)(t.mo,{separator:"true",children:","}),(0,o.jsx)(t.mn,{children:"1"}),(0,o.jsx)(t.mo,{stretchy:"false",children:"]"})]}),(0,o.jsx)(t.annotation,{encoding:"application/x-tex",children:"[-1, 1]"})]})})}),(0,o.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,o.jsxs)(t.span,{className:"base",children:[(0,o.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.jsx)(t.span,{className:"mopen",children:"["}),(0,o.jsx)(t.span,{className:"mord",children:"\u2212"}),(0,o.jsx)(t.span,{className:"mord",children:"1"}),(0,o.jsx)(t.span,{className:"mpunct",children:","}),(0,o.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,o.jsx)(t.span,{className:"mord",children:"1"}),(0,o.jsx)(t.span,{className:"mclose",children:"]"})]})})]})]}),"\n",(0,o.jsxs)(t.li,{children:["we also call balance factor in range ",(0,o.jsxs)(t.span,{className:"katex",children:[(0,o.jsx)(t.span,{className:"katex-mathml",children:(0,o.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(t.semantics,{children:[(0,o.jsxs)(t.mrow,{children:[(0,o.jsx)(t.mo,{stretchy:"false",children:"["}),(0,o.jsx)(t.mo,{children:"\u2212"}),(0,o.jsx)(t.mn,{children:"1"}),(0,o.jsx)(t.mo,{separator:"true",children:","}),(0,o.jsx)(t.mn,{children:"1"}),(0,o.jsx)(t.mo,{stretchy:"false",children:"]"})]}),(0,o.jsx)(t.annotation,{encoding:"application/x-tex",children:"[-1, 1]"})]})})}),(0,o.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,o.jsxs)(t.span,{className:"base",children:[(0,o.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.jsx)(t.span,{className:"mopen",children:"["}),(0,o.jsx)(t.span,{className:"mord",children:"\u2212"}),(0,o.jsx)(t.span,{className:"mord",children:"1"}),(0,o.jsx)(t.span,{className:"mpunct",children:","}),(0,o.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,o.jsx)(t.span,{className:"mord",children:"1"}),(0,o.jsx)(t.span,{className:"mclose",children:"]"})]})})]})," as ",(0,o.jsx)(t.strong,{children:"AVL invariant"})]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"AVL have the same methods as the BST do, but need more about keep balanced"}),"\n",(0,o.jsx)(t.h2,{id:"implement",children:"Implement"}),"\n",(0,o.jsx)(t.p,{children:"To have AVL Tree, we should modify the implement of BST."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Insert:"})," The same insert with modify the height of node to track if balance factor. After insert, check the AVL invariant if satisfied. If not, then we need to do rebalance/rotation."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Delete"}),": The same delete with modify the height of node to track if balance factor. After delete, check the AVL invariant if satisfied. If not, then we need to do rebalance/rotation."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Rebalance:"})," base on balance factor negative or not, we will swap left/right children with parent; more specifically, we have 4 cases  after insert/delete:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"insert/delete right, then left tree's right's height > left tree's left's: rotate left about left tree and then rotate right about root"}),"\n",(0,o.jsx)(t.li,{children:"left tree's right's height <= left tree's left's: rotate right about root"}),"\n",(0,o.jsx)(t.li,{children:"insert/delete left,  then right tree's left's height > right tree's right's: rotate right about right tree and then rotate left about root"}),"\n",(0,o.jsx)(t.li,{children:"right tree's left's height <= tree's right's: rotate left about root"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Rotation:"})}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"rotate left: swap root with right tree where root new right = right tree's left and right tree's left = root;"}),"\n",(0,o.jsx)(t.li,{children:"rotate right: swap root with left tree where root new left = right tree's right and left tree's right = root;"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Code in python given in lec:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"def AVL-INSERT(root, x):\r\n    if root is NIL:  # found insertion point\r\n        root = TreeNode(x)  # initial height = 0\r\n    elif x.key < root.item.key:\r\n        root.left = AVL-INSERT(root.left, x)\r\n        root = AVL-REBALANCE-RIGHT(root)\r\n    elif x.key > root.item.key:\r\n        root.right = AVL-INSERT(root.right, x)\r\n        root = AVL-REBALANCE-LEFT(root)\r\n    else:  # x.key == root.item.key\r\n        # Just replace root's item with x -- nothing else changes.\r\n        root.item = x\r\n        return root\r\n\r\ndef AVL-REBALANCE-LEFT(root):  # Precondition: root is not NIL\r\n    # Recalculate height.\r\n    root.height = 1 + max(root.left.height, root.right.height)\r\n    # Rebalance if necessary.\r\n    if root.right.height > 1 + root.left.height:\r\n        # Perform double rotation if necessary.\r\n        if root.right.left.height > root.right.right.height:\r\n            root.right = AVL-ROTATE-RIGHT(root.right)\r\n            root = AVL-ROTATE-LEFT(root)\r\n            return root\r\n\r\ndef AVL-REBALANCE-RIGHT(root):  # Precondition: root is not NIL\r\n    # Recalculate height\r\n    root.height = 1 + max(root.left.height, root.right.height)\r\n    # Rebalance if necessary.\r\n    if root.left.height > 1 + root.right.height:\r\n        # Perform double rotation if necessary.\r\n        if root.left.right.height > root.left.left.height:\r\n            root.left = AVL-ROTATE-LEFT(root.left)\r\n            root = AVL-ROTATE-RIGHT(root)\r\n            return root\r\n        \r\ndef AVL-ROTATE-LEFT(parent): # Precond: parent != NIL, parent.right != NIL\r\n    # Rearrange references.\r\n    child = parent.right\r\n    parent.right = child.left\r\n    child.left = parent\r\n    # Update heights.\r\n    parent.height = 1 + max(parent.left.height, parent.right.height)\r\n    child.height = 1 + max(child.left.height, child.right.height)\r\n    # Return new parent.\r\n    return child\r\n\r\ndef AVL-ROTATE-RIGHT(parent): # Precond: parent != NIL, parent.left != NIL\r\n    # Rearrange references.\r\n    child = parent.left\r\n    parent.left = child.right\r\n    child.right = parent\r\n    # Update heights.\r\n    parent.height = 1 + max(parent.left.height, parent.right.height)\r\n    child.height = 1 + max(child.left.height, child.right.height)\r\n    # Return new parent.\r\n    return child\r\n\r\ndef AVL-DELETE(root, x):\r\n    if root is NIL:\r\n        pass  # nothing to remove\r\n    elif x.key < root.item.key:\r\n        root.left = AVL-DELETE(root.left, x)\r\n        root = AVL-REBALANCE-LEFT(root)  # careful with direction!\r\n    elif x.key > root.item.key:\r\n        root.right = AVL-DELETE(root.right, x)\r\n        root = AVL-REBALANCE-RIGHT(root)  # careful with direction!\r\n    else:  # x.key == root.item.key\r\n        if root.left is NIL:\r\n            root = root.right  # includes case root.right is NIL\r\n        elif root.right is NIL:\r\n            root = root.left\r\n        else:\r\n            # Select whether to replace root.item with its predecessor or\r\n            # its successor, depending on the heights of subtrees.\r\n            if root.left.height > root.right.height:\r\n                root.item, root.left = AVL-DELETE-MAX(root.left)\r\n            else:\r\n                root.item, root.right = AVL-DELETE-MIN(root.right)\r\n                # Height might have changed, but no rebalancing for root.\r\n                root.height = 1 + max(root.left.height, root.right.height)\r\n                return root\r\n\r\ndef AVL-DELETE-MIN(root):\r\n    if root.left is NIL:\r\n        return root.item, root.right\r\n    else:\r\n        item, root.left = AVL-DELETE-MIN(root.left)\r\n        root = AVL-REBALANCE-LEFT(root)\r\n        return item, root\r\n\r\ndef AVL-DELETE-MAX(root):\r\n    if root.right is NIL:\r\n        return root.item, root.left\r\n    else:\r\n        item, root.right = AVL-DELETE-MAX(root.right)\r\n        root = AVL-REBALANCE-RIGHT(root)\r\n        return item, root\r\n\r\n\r\ndef AVL-SEARCH(root, k):\r\n    if root is NIL:  # k not in root's subtree\r\n        pass  # NIL will be returned below\r\n    elif k < root.item.key:\r\n        root = AVL-SEARCH(root.left, k)\r\n    elif k > root.item.key:\r\n        root = AVL-SEARCH(root.right, k)\r\n    else:  # x.key == root.item.key\r\n        pass  # root is the node we want\r\n    return root\n"})}),"\n",(0,o.jsx)(t.h2,{id:"worst-case-time-complexity",children:"Worst-Case Time Complexity"}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{style:{textAlign:"center"},children:"Operation"}),(0,o.jsx)(t.th,{style:{textAlign:"center"},children:"Time Complexity"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"center"},children:"Search"}),(0,o.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"center"},children:"Insert"}),(0,o.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"center"},children:"Delete"}),(0,o.jsx)(t.td,{style:{textAlign:"center"},children:"O(log n)"})]})]})]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>a});var n=r(6540);const o={},i=n.createContext(o);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);