题目为，给两个不同字符可以使用的数量称之为`A, B` 以及两个数`MA,MB`来表达`A,B`可以最长的连续组合的数量。

## 笨笨想法1
对于这道题我的首先想法是，先放A再放B，然后反着再来一遍在比较结果。但是得到了问题1: 放多少，怎么放
case 1, `MA >= A, MB >= B`. 在这种情况下 怎么放都可以, 就是等于`A+B`
case 2, `MA < A, MB >= B`. 可以放`[MA/A, A]`个不连续的字符,  这时候`B`直接平铺，而我们需要见缝插针插进最多数量的`A`，而最多可以插入的`A`的数量为`A`, 最大组数为`B + 1`. 如果`B+1`不够插入`A`的话，最多只能插入`(B+1)*MA`个字符。所以结果为`B + min((B+1)*MA, A)`
case 3, `MA >= A, MB < B`. 同case 2, 反转结果为`A + min((A+1)*MB, B)`
case 4, `MA < A, MB < B`. 最复杂的情况。这种时候只需考虑`A`和`B`的情况即可，`A <= B`那么再怎么挣扎给`B`留的位置最多也就`A + 1`个，也就是说这种时候取`A + min(B, (A+1)*MB)`, 反之亦然. 剩下的边界条件只剩下 `MA, MB`为0的情况，`MA = 0` 那么在这里只能放`MB` 反之亦然

错误总结: 过渡专注组内情况，即一直在思考`MA`和`A`的，`MB`和`B`的关系 导致 case4想的时间过长

## 总结想法1

通过笨笨不难看出来，`A,B`所用的组的数量还是很重要的，我们提前设好`a, b`为他们结果所用的组数，而结果从case1-4总结出来就是`min(a*MA, A) + min(b*MB, B)`. 那我们只需要做的就是去找这两个，不难预设`a = MA == 0? 0: B + 1` 以及`b = MB == 0? 0: A + 1`
不考虑`MA=0, MB=0`的情况，再去回头看不同的case
case1: `min(a*MA, A) + min(b*MB, B) = A + B`，这样必须得满足 `a*MA = (B+1)*MA >= A => B + 1 >= A/MA` 以及 `A + 1 >= B/MB`, 再回顾条件`MA >= A, MB >= B`不难发现条件是一直满足的
case 2: `min(a*MA, A) + min(b*MB, B) = min((B+1)*MA, A) + B`，这里只需要满足`A + 1 >= B/MB`, 从条件`MB >= B`中可以获得，所以成立
case 3, `min(a*MA, A) + min(b*MB, B) = A + min((A+1)*MB, B)` 同上
case 4, `min(a*MA, A) + min(b*MB, B) = A + min((A+1)*MB, B) = min((B+1)*MA, A) + B` 在不同情况下，该如何将他们合并在一起呢？算了就这样吧....
补充`MA = 0, return min(MB, B)), MB = 0, return min(MA, A)`，结合这两个可以可以写成`if MA = 0 or MB = 0: return min(MB, B) + min(MA, A)`